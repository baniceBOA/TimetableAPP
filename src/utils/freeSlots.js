import { DAYS, START_HOUR, END_HOUR, SLOTS_PER_HOUR } from "../constants";
import { toMinutes } from "./time";
function clipToBounds(s, e, bs, be){ s = Math.max(s, bs); e = Math.min(e, be); return e<=s? null:[s,e]; }
function mergeIntervals(ints){ const out=[]; for(const [s,e] of ints){ if(!out.length||s>out[out.length-1][1]) out.push([s,e]); else out[out.length-1][1]=Math.max(out[out.length-1][1],e);} return out; }
function ceilToSlot(mins, slotMins){ return Math.ceil(mins/slotMins)*slotMins; }
function freeSlotsForDay(events, dayIndex, teacherId, roomId, lenMins, slotMins){ const ds=START_HOUR*60, de=END_HOUR*60; const busy=[]; for(const e of events){ if(e.dayIndex!==dayIndex) continue; const tBusy = teacherId && e.teacherId===teacherId; const rBusy = roomId && e.roomId===roomId; if(!tBusy && !rBusy) continue; const c = clipToBounds(toMinutes(e.start), toMinutes(e.end), ds, de); if(c) busy.push(c);} busy.sort((a,b)=>a[0]-b[0]); const merged = mergeIntervals(busy); const gaps=[]; let cursor=ds; for(const [bs,be] of merged){ if(bs>cursor) gaps.push([cursor,bs]); cursor=Math.max(cursor,be);} if(cursor<de) gaps.push([cursor,de]); const out=[]; for(const [gs,ge] of gaps){ let s=ceilToSlot(gs, slotMins); while(s+lenMins<=ge){ out.push({ dayIndex, start:`${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`, end:`${String(Math.floor((s+lenMins)/60)).padStart(2,'0')}:${String((s+lenMins)%60).padStart(2,'0')}`}); s+=slotMins; } } return out; }
export function suggestFreeSlots({ events, teacherId, roomId, dayIndex=null, classLenMins=60, limit=16 }){ const slotMins=60/SLOTS_PER_HOUR; const days=dayIndex!=null? [dayIndex]: Array.from({length:DAYS.length},(_,i)=>i); const all=[]; for(const d of days){ all.push(...freeSlotsForDay(events,d,teacherId,roomId,classLenMins,slotMins)); } all.sort((a,b)=> (a.dayIndex-b.dayIndex) || a.start.localeCompare(b.start)); return all.slice(0,limit); }
